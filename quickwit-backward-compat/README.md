# Backward compatibility test project.

This is just a project used to test backward compatibility of Quickwit.
Right now, only SplitMetadata is tested.

We want to be able to read all past versions of SplitMetadata, but only write the most recent format.
The tests consists in pairs of json file.
XXXX.json and XXXX.expected.json

XXXX.json consists in a json file in an old format.
XXXX.expected.json consists in the expected result of
serialize_new_version(deserialize(XXXX.json)).

## Change of format autodetection

This project contains a build.rs design to help autodetect a change in the format.
This script generates a json file from a given default SplitMetadata object.
The script will generate two files XXXX.json and XXXX.expected.json.

The two files will be identical. This is expected as this is a unit test for the
most recent version.

## How do I update the schema?

There two ways to types of upgrade.

### Naturally backward compatible change

Serde offers some attributes to make backward compatible change to our model.
For instance, it is possible to add a new field to a struct and slap
a `serde(default)` attribute to it in order to handle older serialized version of the
struct.
It is also possible to rename a field in a backward compatible manner
by using the `#[serde(alias)]`.

For this type of change it is not required to update the serialization version.

When introducing such a change:
- modify your model with the help of the attributes above.
- commit the 2 files that were autogenerated by build.rs
- fix the `.expected.json` that failed.

### Change requiring a new version

For heavier changes requiring a new version,

- create a new item in the `VersionedSplitMetadataDeserializeHelper`.
- update split metadata
- make sure the conversion from SplitMetadata to VersionedSplitMetadata creates the new item.
- commit the 2 files that were autogenerated by build.rs
- fix the expected.json files

