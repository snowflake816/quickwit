# Backward compatibility test project.

This is just a project used to test backward compatibility of Quickwit.
Right now, `SplitMetadata`, `IndexMetadata`, and FileBackedIndex` are tested.

We want to be able to read all past versions of these files, but only write the most recent format.
The tests consist of pairs of JSON files.
XXXX.json and XXXX.expected.json

XXXX.json consists of a JSON file in an old format.
XXXX.expected.json consists of the expected result of
serialize_new_version(deserialize(XXXX.json)).

## Change of format autodetection

Two things need to happen upon a change of format.

### Updating expected.json

Of course to make all of this work, we need to keep `*.expected.json` files up-to-date
with the changes of format.

This is done in a semi-automatic fashion.

On a first pass, `deserialize(original_json) == deserialize(expectation_json)`.
On a second pass, the tests are checking that `expectation_json = serialize(deserialize(expectation_json))`.

When changing the json format, it is expected to see this test fail.
The unit test then updates automatically the expected.json. The developer just has to
check the diff of the result (in particular no information should be lost) and commit the updated expected.json
files.

Adding this update operation within the unit test is a tad unexpected, but it has the merit of
integrating well with CI. If a developer forgets to update the expected.json file,
the CI will catch it.

### Adding a new test case.

If the serialization format changes, the unit test will also automatically add
a new unit test generated from a sample tested object.
Concretely, it will just write two files XXXX.json and XXXX.expected.json.

The two files will be identical. This is expected as this is a unit test for the
most recent version.

The unit test will start making sense in future updates thanks to the update phase
described in the previous section.

## How do I update `{IndexMetadata, SplitMetadata, FileBackedIndex}`?

There are two types of upgrades.

### Naturally backward compatible change

Serde offers some attributes to make backward compatible change to our model.
For instance, it is possible to add a new field to a struct and slap
a `serde(default)` attribute to it in order to handle older serialized version of the
struct.
It is also possible to rename a field in a backward compatible manner
by using the `#[serde(alias)]`.

For this type of change it is not required to update the serialization version.

When introducing such a change:
- modify your model with the help of the attributes above.
- commit the 2 files that were autogenerated by build.rs
- fix the `.expected.json` that failed.

### Change requiring a new version

For heavier changes requiring a new version,

- create a new item in the `VersionedXXXDeserializeHelper` struct.
- update split metadata
- make sure the conversion from SplitMetadata to VersionedSplitMetadata creates the new item.
- run unit tests
- commit the 2 files that were autogenerated by build.rs
- eyeball and commit the autoupdated `expected.json` files
