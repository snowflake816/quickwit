// Copyright (C) 2022 Quickwit, Inc.
//
// Quickwit is offered under the AGPL v3.0 and as commercial software.
// For commercial licensing, contact us at hello@quickwit.io.
//
// AGPL:
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

use std::collections::{BTreeMap, BTreeSet};
use std::num::NonZeroU32;

use anyhow::{bail, Context};
use quickwit_proto::SearchRequest;
use serde::{Deserialize, Serialize};
use serde_json::{self, Value as JsonValue};
use tantivy::query::Query;
use tantivy::schema::{Cardinality, Field, FieldType, Schema, Value as TantivyValue, STORED};
use tantivy::Document;

use super::field_mapping_entry::QuickwitTextTokenizer;
use super::DefaultDocMapperBuilder;
use crate::default_doc_mapper::mapping_tree::{build_mapping_tree, MappingNode, MappingTree};
pub use crate::default_doc_mapper::QuickwitJsonOptions;
use crate::doc_mapper::{JsonObject, Partition};
use crate::query_builder::build_query;
use crate::routing_expression::RoutingExpr;
use crate::{
    DocMapper, DocParsingError, ModeType, QueryParserError, WarmupInfo, DYNAMIC_FIELD_NAME,
    SOURCE_FIELD_NAME,
};

/// Defines how an unmapped field should be handled.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub(crate) enum Mode {
    Lenient,
    Strict,
    Dynamic(QuickwitJsonOptions),
}

impl Mode {
    pub fn mode_type(&self) -> ModeType {
        match self {
            Mode::Lenient => ModeType::Lenient,
            Mode::Strict => ModeType::Strict,
            Mode::Dynamic(_) => ModeType::Dynamic,
        }
    }
}

impl Default for Mode {
    fn default() -> Self {
        Mode::Lenient
    }
}

/// Default [`DocMapper`] implementation
/// which defines a set of rules to map json fields
/// to tantivy index fields.
///
/// The mains rules are defined by the field mappings.
#[derive(Serialize, Deserialize, Clone)]
#[serde(try_from = "DefaultDocMapperBuilder", into = "DefaultDocMapperBuilder")]
pub struct DefaultDocMapper {
    /// Field in which the source should be stored.
    /// This field is only valid when using the schema associated with the default
    /// doc mapper, and therefore cannot be used in the `query` method.
    source_field: Option<Field>,
    /// Field in which the dynamically mapped fields should be stored.
    /// This field is only valid when using the schema associated with the default
    /// doc mapper, and therefore cannot be used in the `query` method.
    dynamic_field: Option<Field>,
    /// Default list of field names used for search.
    default_search_field_names: Vec<String>,
    /// Timestamp field name.
    timestamp_field_name: Option<String>,
    /// Root node of the field mapping tree.
    /// See [`MappingNode`] and [`MappingTree`].
    field_mappings: MappingNode,
    /// Schema generated by the store source and field mappings parameters.
    schema: Schema,
    /// List of field names used for tagging.
    tag_field_names: BTreeSet<String>,
    /// The partition key is a DSL used to route documents
    /// into specific splits.
    partition_key: RoutingExpr,
    /// Maximum number of partitions
    max_num_partitions: NonZeroU32,
    /// List of required fields. Right now this is the list of fast fields.
    required_fields: Vec<Field>,
    /// Defines how unmapped fields should be handle.
    mode: Mode,
}

impl DefaultDocMapper {
    fn check_missing_required_fields(&self, doc: &Document) -> Result<(), DocParsingError> {
        for &required_field in &self.required_fields {
            if doc.get_first(required_field).is_none() {
                let missing_field_name = self.schema.get_field_name(required_field);
                return Err(DocParsingError::RequiredFastField(
                    missing_field_name.to_string(),
                ));
            }
        }
        Ok(())
    }

    /// Default maximum number of partitions.
    pub fn default_max_num_partitions() -> NonZeroU32 {
        NonZeroU32::new(200).unwrap()
    }
}

fn validate_tag_fields(tag_fields: &[String], schema: &Schema) -> anyhow::Result<()> {
    for tag_field in tag_fields {
        let field = schema
            .get_field(tag_field)
            .ok_or_else(|| anyhow::anyhow!("Tag field `{}` does not exist.", tag_field))?;
        let field_type = schema.get_field_entry(field).field_type();
        match field_type {
            FieldType::Str(options) => {
                let tokenizer_opt = options
                    .get_indexing_options()
                    .map(|text_options| text_options.tokenizer());

                if tokenizer_opt != Some(QuickwitTextTokenizer::Raw.get_name()) {
                    bail!(
                        "Tags collection is only allowed on text fields with the `raw` tokenizer."
                    );
                }
            }
            FieldType::Bytes(_) => {
                bail!("Tags collection is not allowed on `bytes` fields.")
            }
            _ => (),
        }
    }
    Ok(())
}

fn list_required_fields_for_node(node: &MappingNode) -> Vec<Field> {
    node.children().flat_map(list_required_fields).collect()
}

fn list_required_fields(field_mappings: &MappingTree) -> Vec<Field> {
    match field_mappings {
        MappingTree::Leaf(leaf) => {
            // single value fast fields are required since null handling in tantivy is broken (will
            // be fixed with https://github.com/quickwit-oss/tantivy/issues/1575)
            if leaf.get_type().is_single_value_fast_field() {
                vec![leaf.field()]
            } else {
                Vec::new()
            }
        }
        MappingTree::Node(node) => list_required_fields_for_node(node),
    }
}

fn resolve_timestamp_field(
    timestamp_field_name_opt: Option<&String>,
    schema: &Schema,
) -> anyhow::Result<()> {
    if let Some(ref timestamp_field_name) = timestamp_field_name_opt {
        let timestamp_field = schema
            .get_field(timestamp_field_name)
            .with_context(|| format!("Unknown timestamp field: `{timestamp_field_name}`"))?;

        let timestamp_field_entry = schema.get_field_entry(timestamp_field);
        if !timestamp_field_entry.is_fast() {
            bail!(
                "Timestamp field must be a fast field, please add the fast property to your field \
                 `{}`.",
                timestamp_field_name
            )
        }
        match timestamp_field_entry.field_type() {
            FieldType::Date(options) => {
                if options.get_fastfield_cardinality() == Some(Cardinality::MultiValues) {
                    bail!(
                        "Timestamp field cannot be an array, please change your field `{}` from \
                         an array to a single value.",
                        timestamp_field_name
                    )
                }
            }
            _ => {
                bail!(
                    "Timestamp field must be of type datetime, please change your field type `{}` \
                     to datetime.",
                    timestamp_field_name
                )
            }
        }
    }
    Ok(())
}

impl TryFrom<DefaultDocMapperBuilder> for DefaultDocMapper {
    type Error = anyhow::Error;

    fn try_from(builder: DefaultDocMapperBuilder) -> anyhow::Result<DefaultDocMapper> {
        let mode = builder.mode()?;
        let mut schema_builder = Schema::builder();
        let field_mappings = build_mapping_tree(&builder.field_mappings, &mut schema_builder)?;
        let source_field = if builder.store_source {
            Some(schema_builder.add_json_field(SOURCE_FIELD_NAME, STORED))
        } else {
            None
        };

        let dynamic_field = if let Mode::Dynamic(json_options) = &mode {
            Some(schema_builder.add_json_field(DYNAMIC_FIELD_NAME, json_options.clone()))
        } else {
            None
        };

        let schema = schema_builder.build();

        // validate fast fields
        validate_tag_fields(&builder.tag_fields, &schema)?;

        // Resolve default search fields
        let mut default_search_field_names = Vec::new();
        for field_name in &builder.default_search_fields {
            if default_search_field_names.contains(field_name) {
                bail!("Duplicated default search field: `{}`", field_name)
            }
            schema
                .get_field(field_name)
                .with_context(|| format!("Unknown default search field: `{field_name}`"))?;
            default_search_field_names.push(field_name.clone());
        }

        resolve_timestamp_field(builder.timestamp_field.as_ref(), &schema)?;

        // Resolve tag fields
        let mut tag_field_names: BTreeSet<String> = Default::default();
        for tag_field_name in &builder.tag_fields {
            if tag_field_names.contains(tag_field_name) {
                bail!("Duplicated tag field: `{}`", tag_field_name)
            }
            schema
                .get_field(tag_field_name)
                .with_context(|| format!("Unknown tag field: `{tag_field_name}`"))?;
            tag_field_names.insert(tag_field_name.clone());
        }

        let required_fields = list_required_fields_for_node(&field_mappings);
        let partition_key = RoutingExpr::new(builder.partition_key.as_deref().unwrap_or(""))
            .context("Failed to interpret the partition key.")?;
        Ok(DefaultDocMapper {
            schema,
            source_field,
            dynamic_field,
            default_search_field_names,
            timestamp_field_name: builder.timestamp_field,
            field_mappings,
            tag_field_names,
            required_fields,
            partition_key,
            max_num_partitions: builder.max_num_partitions,
            mode,
        })
    }
}

impl From<DefaultDocMapper> for DefaultDocMapperBuilder {
    fn from(default_doc_mapper: DefaultDocMapper) -> Self {
        let mode = default_doc_mapper.mode.mode_type();
        let dynamic_mapping = match &default_doc_mapper.mode {
            Mode::Dynamic(mapping_options) => Some(mapping_options.clone()),
            _ => None,
        };
        let partition_key_str = default_doc_mapper.partition_key.to_string();
        let partition_key_opt: Option<String> = if partition_key_str.is_empty() {
            None
        } else {
            Some(partition_key_str)
        };
        Self {
            store_source: default_doc_mapper.source_field.is_some(),
            timestamp_field: default_doc_mapper.timestamp_field_name(),
            field_mappings: default_doc_mapper.field_mappings.into(),
            tag_fields: default_doc_mapper.tag_field_names.into_iter().collect(),
            default_search_fields: default_doc_mapper.default_search_field_names,
            mode,
            dynamic_mapping,
            partition_key: partition_key_opt,
            max_num_partitions: default_doc_mapper.max_num_partitions,
        }
    }
}

impl std::fmt::Debug for DefaultDocMapper {
    fn fmt(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter
            .debug_struct("DefaultDocMapper")
            .field("store_source", &self.source_field.is_some())
            .field(
                "default_search_field_names",
                &self.default_search_field_names,
            )
            .field("timestamp_field_name", &self.timestamp_field_name())
            // TODO: complete it.
            .finish()
    }
}

fn extract_single_obj(
    doc: &mut BTreeMap<String, Vec<TantivyValue>>,
    key: &str,
) -> anyhow::Result<Option<serde_json::Map<String, JsonValue>>> {
    let mut values = if let Some(values) = doc.remove(key) {
        values
    } else {
        return Ok(None);
    };
    if values.len() > 1 {
        bail!(
            "Invalid named document. There are more than 1 value associated to the `{key}` field."
        );
    }
    match values.pop() {
        Some(TantivyValue::JsonObject(dynamic_json_obj)) => Ok(Some(dynamic_json_obj)),
        Some(_) => {
            bail!("The `{key}` value has to be a json object.");
        }
        None => Ok(None),
    }
}

#[typetag::serde(name = "default")]
impl DocMapper for DefaultDocMapper {
    fn doc_from_json_obj(
        &self,
        json_obj: JsonObject,
    ) -> Result<(Partition, Document), DocParsingError> {
        let partition: Partition = self.partition_key.eval_hash(&json_obj);

        let mut dynamic_json_obj = serde_json::Map::default();
        let mut field_path = Vec::new();
        let mut document = Document::default();

        if let Some(source_field) = self.source_field {
            document.add_json_object(source_field, json_obj.clone());
        }

        let mode = self.mode.mode_type();
        self.field_mappings.doc_from_json(
            json_obj,
            mode,
            &mut document,
            &mut field_path,
            &mut dynamic_json_obj,
        )?;

        if let Some(dynamic_field) = self.dynamic_field {
            if !dynamic_json_obj.is_empty() {
                document.add_json_object(dynamic_field, dynamic_json_obj);
            }
        }

        self.check_missing_required_fields(&document)?;
        Ok((partition, document))
    }

    fn doc_to_json(
        &self,
        mut named_doc: BTreeMap<String, Vec<TantivyValue>>,
    ) -> anyhow::Result<serde_json::Map<String, JsonValue>> {
        let mut doc_json =
            extract_single_obj(&mut named_doc, DYNAMIC_FIELD_NAME)?.unwrap_or_default();
        let mut field_path: Vec<&str> = Vec::new();
        self.field_mappings
            .populate_json(&mut named_doc, &mut field_path, &mut doc_json);

        if let Some(source_json) = extract_single_obj(&mut named_doc, SOURCE_FIELD_NAME)? {
            doc_json.insert(
                SOURCE_FIELD_NAME.to_string(),
                JsonValue::Object(source_json),
            );
        }

        Ok(doc_json)
    }

    fn query(
        &self,
        split_schema: Schema,
        request: &SearchRequest,
    ) -> Result<(Box<dyn Query>, WarmupInfo), QueryParserError> {
        let mut tantivy_default_search_field_names = self.default_search_field_names.clone();
        if let Mode::Dynamic(default_mapping_options) = &self.mode {
            if default_mapping_options.indexed {
                tantivy_default_search_field_names.push(DYNAMIC_FIELD_NAME.to_string());
            }
        }
        build_query(split_schema, request, &tantivy_default_search_field_names)
    }

    fn schema(&self) -> Schema {
        self.schema.clone()
    }

    fn timestamp_field_name(&self) -> Option<String> {
        self.timestamp_field_name.clone()
    }

    fn tag_field_names(&self) -> BTreeSet<String> {
        self.tag_field_names.clone()
    }

    fn max_num_partitions(&self) -> NonZeroU32 {
        self.max_num_partitions
    }
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use quickwit_proto::SearchRequest;
    use serde_json::{self, json, Value as JsonValue};
    use tantivy::schema::{FieldType, Type, Value as TantivyValue};

    use super::DefaultDocMapper;
    use crate::{
        DefaultDocMapperBuilder, DocMapper, DocParsingError, DYNAMIC_FIELD_NAME, SOURCE_FIELD_NAME,
    };

    fn example_json_doc_value() -> JsonValue {
        serde_json::json!({
            "timestamp": 1586960586i64,
            "body": "20200415T072306-0700 INFO This is a great log",
            "response_date2": "2021-12-19T16:39:57+00:00",
            "response_date": "2021-12-19T16:39:57Z",
            "response_time": 2.3,
            "response_payload": "YWJj",
            "owner": "foo",
            "isImportant": false,
            "attributes": {
                "server": "ABC",
                "tags": [22, 23],
                "server.status": ["200", "201"],
                "server.payload": ["YQ==", "Yg=="]
            }
        })
    }

    const EXPECTED_JSON_PATHS_AND_VALUES: &str = r#"{
            "timestamp": ["2020-04-15T14:23:06Z"],
            "body": ["20200415T072306-0700 INFO This is a great log"],
            "response_date": ["2021-12-19T16:39:57Z"],
            "response_time": [2.3],
            "response_payload": ["YWJj"],
            "owner": ["foo"],
            "isImportant": [false],
            "body_other_tokenizer": ["20200415T072306-0700 INFO This is a great log"],
            "attributes.server": ["ABC"],
            "attributes.server\\.payload": ["YQ==", "Yg=="],
            "attributes.tags": [22, 23],
            "attributes.server\\.status": ["200", "201"]
        }"#;

    #[test]
    fn test_json_deserialize() -> anyhow::Result<()> {
        let config = crate::default_doc_mapper_for_test();
        assert!(config.source_field.is_some());
        let mut default_search_field_names: Vec<String> = config.default_search_field_names;
        default_search_field_names.sort();
        assert_eq!(
            default_search_field_names,
            ["attributes.server", r#"attributes.server\.status"#, "body"]
        );
        assert_eq!(config.field_mappings.num_fields(), 10);
        Ok(())
    }

    #[test]
    fn test_parsing_document() {
        let json_doc = example_json_doc_value();
        let doc_mapper = crate::default_doc_mapper_for_test();
        let (_, document) = doc_mapper
            .doc_from_json_obj(json_doc.as_object().unwrap().clone())
            .unwrap();
        let schema = doc_mapper.schema();
        // 8 property entry + 1 field "_source" + two fields values for "tags" field
        // + 2 values inf "server.status" field + 2 values in "server.payload" field
        assert_eq!(document.len(), 15);
        let expected_json_paths_and_values: HashMap<String, JsonValue> =
            serde_json::from_str(EXPECTED_JSON_PATHS_AND_VALUES).unwrap();
        document.field_values().iter().for_each(|field_value| {
            let field_name = schema.get_field_name(field_value.field());
            if field_name == SOURCE_FIELD_NAME {
                assert_eq!(field_value.value().as_json(), json_doc.as_object());
            } else if field_name == DYNAMIC_FIELD_NAME {
                assert_eq!(
                    field_value.value().as_json(),
                    json!({"response_date2": "2021-12-19T16:39:57+00:00"}).as_object()
                );
            } else {
                let value = serde_json::to_string(field_value.value()).unwrap();
                let is_value_in_expected_values = expected_json_paths_and_values
                    .get(field_name)
                    .unwrap()
                    .as_array()
                    .unwrap()
                    .iter()
                    .map(|expected_value| format!("{expected_value}"))
                    .any(|expected_value| expected_value == value);
                if !is_value_in_expected_values {
                    panic!("Could not find: {value:?} in {expected_json_paths_and_values:?}");
                }
            }
        });
    }

    #[test]
    fn test_accept_parsing_document_with_unknown_fields_and_missing_fields() {
        let doc_mapper = crate::default_doc_mapper_for_test();
        doc_mapper
            .doc_from_json_str(
                r#"{
                "timestamp": 1586960586000,
                "unknown_field": "20200415T072306-0700 INFO This is a great log",
                "response_date": "2021-12-19T16:39:57+00:00",
                "response_time": 12,
                "response_payload": "YWJj"
            }"#,
            )
            .unwrap();
    }

    #[test]
    fn test_fail_parsing_document_with_missing_fast_field() {
        let doc_mapper = crate::default_doc_mapper_for_test();
        let result = doc_mapper.doc_from_json_str(
            r#"{
                "timestamp": 1586960586000,
                "unknown_field": "20200415T072306-0700 INFO This is a great log",
                "response_date": "2021-12-19T16:39:57+00:00",
                "response_time": 12
            }"#,
        );
        assert!(result.is_err());
        let error = result.unwrap_err();
        assert_eq!(
            error,
            DocParsingError::RequiredFastField("response_payload".to_owned())
        );
    }

    #[test]
    fn test_fail_to_parse_document_with_wrong_cardinality() -> anyhow::Result<()> {
        let doc_mapper = crate::default_doc_mapper_for_test();
        let result = doc_mapper.doc_from_json_str(
            r#"{
                "timestamp": 1586960586000,
                "body": ["text 1", "text 2"]
            }"#,
        );
        assert!(result.is_err());
        let error = result.unwrap_err();
        assert_eq!(
            error,
            DocParsingError::MultiValuesNotSupported("body".to_owned())
        );
        Ok(())
    }

    #[test]
    fn test_fail_to_parse_document_with_wrong_value() -> anyhow::Result<()> {
        let doc_mapper = crate::default_doc_mapper_for_test();
        let result = doc_mapper.doc_from_json_str(
            r#"{
                "timestamp": 1586960586000,
                "body": 1
            }"#,
        );
        assert!(result.is_err());
        let error = result.unwrap_err();
        assert_eq!(
            error,
            DocParsingError::ValueError(
                "body".to_owned(),
                "Expected JSON string, got `1`.".to_owned()
            )
        );
        Ok(())
    }

    #[test]
    fn test_fail_to_build_doc_mapper_with_non_fast_timestamp_field() -> anyhow::Result<()> {
        let doc_mapper = r#"{
            "default_search_fields": [],
            "timestamp_field": "timestamp",
            "tag_fields": [],
            "field_mappings": [
                {
                    "name": "timestamp",
                    "type": "text"
                }
            ]
        }"#;
        let builder = serde_json::from_str::<DefaultDocMapperBuilder>(doc_mapper)?;
        let expected_msg = "Timestamp field must be a fast field, please add the fast property to \
                            your field `timestamp`."
            .to_string();
        assert_eq!(builder.try_build().unwrap_err().to_string(), expected_msg);
        Ok(())
    }

    #[test]
    fn test_fail_to_build_doc_mapper_with_duplicate_fields() -> anyhow::Result<()> {
        {
            let doc_mapper = r#"{
                "field_mappings": [
                    {"name": "body","type": "text"},
                    {"name": "body","type": "bytes"}
                ]
            }"#;
            let builder = serde_json::from_str::<DefaultDocMapperBuilder>(doc_mapper)?;
            let expected_msg = "Duplicated field definition `body`.".to_string();
            assert_eq!(builder.try_build().unwrap_err().to_string(), expected_msg);
        }

        {
            let doc_mapper = r#"{
                "field_mappings": [
                    {
                        "name": "identity",
                        "type": "object",
                        "field_mappings": [
                            {"type": "text", "name": "username"},
                            {"type": "text", "name": "username"}
                        ]
                    },
                    {"type": "text", "name": "body"}
                ]
            }"#;
            let builder = serde_json::from_str::<DefaultDocMapperBuilder>(doc_mapper)?;
            let expected_msg = "Duplicated field definition `username`.".to_string();
            assert_eq!(builder.try_build().unwrap_err().to_string(), expected_msg);
        }
        Ok(())
    }

    #[test]
    fn test_should_build_doc_mapper_with_duplicate_fields_at_different_level() -> anyhow::Result<()>
    {
        let doc_mapper = r#"{
            "field_mappings": [
                {
                    "name": "identity",
                    "type": "object",
                    "field_mappings": [
                        {"type": "text", "name": "body"},
                        {"type": "text", "name": "username"}
                    ]
                },
                {"type": "text", "name": "body"}
            ]
        }"#;
        let builder = serde_json::from_str::<DefaultDocMapperBuilder>(doc_mapper)?;
        assert!(builder.try_build().is_ok());
        Ok(())
    }

    #[test]
    fn test_fail_to_build_doc_mapper_with_multivalued_timestamp_field() -> anyhow::Result<()> {
        let doc_mapper = r#"{
            "default_search_fields": [],
            "timestamp_field": "timestamp",
            "tag_fields": [],
            "field_mappings": [
                {
                    "name": "timestamp",
                    "type": "array<datetime>",
                    "fast": true
                }
            ]
        }"#;

        let builder = serde_json::from_str::<DefaultDocMapperBuilder>(doc_mapper)?;
        let expected_msg = "Timestamp field cannot be an array, please change your field \
                            `timestamp` from an array to a single value."
            .to_string();
        assert_eq!(builder.try_build().unwrap_err().to_string(), expected_msg);
        Ok(())
    }

    #[test]
    fn test_fail_with_field_name_equal_to_source() {
        let doc_mapper = r#"{
            "default_search_fields": [],
            "tag_fields": [],
            "field_mappings": [
                {
                    "name": "_source",
                    "type": "i64"
                }
            ]
        }"#;
        let deser_err = serde_json::from_str::<DefaultDocMapperBuilder>(doc_mapper)
            .err()
            .unwrap();
        assert_eq!(
            deser_err.to_string(),
            "Field name `_source` may not start by _ at line 9 column 13"
        );
    }

    #[test]
    fn test_fail_to_parse_document_with_wrong_base64_value() -> anyhow::Result<()> {
        let doc_mapper = r#"{
            "default_search_fields": [],
            "timestamp_field": null,
            "tag_fields": [],
            "field_mappings": [
                {
                    "name": "image",
                    "type": "bytes",
                    "stored": true
                }
            ]
        }"#;
        let builder = serde_json::from_str::<DefaultDocMapperBuilder>(doc_mapper)?;
        let doc_mapper = builder.try_build()?;
        let result = doc_mapper.doc_from_json_str(
            r#"{
            "image": "invalid base64 data"
        }"#,
        );
        let expected_msg = "The field `image` could not be parsed: Expected Base64 string, got \
                            `invalid base64 data`: Invalid byte 32, offset 7.";
        assert_eq!(result.unwrap_err().to_string(), expected_msg);
        Ok(())
    }

    #[test]
    fn test_parse_document_with_tag_fields() {
        let doc_mapper = r#"{
            "default_search_fields": [],
            "timestamp_field": null,
            "tag_fields": ["city"],
            "store_source": true,
            "field_mappings": [
                {
                    "name": "city",
                    "type": "text",
                    "stored": true,
                    "tokenizer": "raw"
                },
                {
                    "name": "image",
                    "type": "bytes",
                    "stored": true
                }
            ]
        }"#;

        let builder = serde_json::from_str::<DefaultDocMapperBuilder>(doc_mapper).unwrap();
        let doc_mapper = builder.try_build().unwrap();
        let schema = doc_mapper.schema();
        let json_doc_value: JsonValue = serde_json::json!({
            "city": "tokio",
            "image": "YWJj"
        });
        let (_, document) = doc_mapper
            .doc_from_json_obj(json_doc_value.as_object().unwrap().clone())
            .unwrap();

        // 2 properties, + 1 value for "_source"
        assert_eq!(document.len(), 3);
        let expected_json_paths_and_values: HashMap<String, JsonValue> = serde_json::from_str(
            r#"{
                "city": ["tokio"],
                "image": ["YWJj"]
            }"#,
        )
        .unwrap();
        document.field_values().iter().for_each(|field_value| {
            let field_name = schema.get_field_name(field_value.field());
            if field_name == SOURCE_FIELD_NAME {
                assert_eq!(field_value.value().as_json(), json_doc_value.as_object());
            } else {
                let value = serde_json::to_string(field_value.value()).unwrap();
                let is_value_in_expected_values = expected_json_paths_and_values
                    .get(field_name)
                    .unwrap()
                    .as_array()
                    .unwrap()
                    .iter()
                    .map(|expected_value| format!("{expected_value}"))
                    .any(|expected_value| expected_value == value);
                assert!(is_value_in_expected_values);
            }
        });
    }

    #[test]
    fn test_fail_to_build_doc_mapper_with_wrong_tag_fields_types() -> anyhow::Result<()> {
        let doc_mapper_one = r#"{
            "default_search_fields": [],
            "tag_fields": ["city"],
            "field_mappings": [
                {
                    "name": "city",
                    "type": "text"
                }
            ]
        }"#;
        assert_eq!(
            serde_json::from_str::<DefaultDocMapperBuilder>(doc_mapper_one)?
                .try_build()
                .unwrap_err()
                .to_string(),
            "Tags collection is only allowed on text fields with the `raw` tokenizer.".to_string(),
        );

        let doc_mapper_two = r#"{
            "default_search_fields": [],
            "tag_fields": ["photo"],
            "field_mappings": [
                {
                    "name": "photo",
                    "type": "bytes"
                }
            ]
        }"#;
        assert_eq!(
            serde_json::from_str::<DefaultDocMapperBuilder>(doc_mapper_two)?
                .try_build()
                .unwrap_err()
                .to_string(),
            "Tags collection is not allowed on `bytes` fields.".to_string(),
        );
        Ok(())
    }

    // See #1132
    #[test]
    fn test_by_default_store_source_is_false_and_fields_are_stored_individually() {
        let doc_mapper = r#"{
            "default_search_fields": [],
            "field_mappings": [
                {
                    "name": "my-field",
                    "type": "u64",
                    "indexed": true
                }
            ]
        }"#;
        let builder = serde_json::from_str::<DefaultDocMapperBuilder>(doc_mapper).unwrap();
        let default_doc_mapper = builder.try_build().unwrap();
        assert!(default_doc_mapper.source_field.is_none());
        let schema = default_doc_mapper.schema();
        let field = schema.get_field("my-field").unwrap();
        let field_entry = schema.get_field_entry(field);
        assert!(field_entry.is_stored());
    }

    #[test]
    fn test_lenient_mode_schema() {
        let default_doc_mapper: DefaultDocMapper =
            serde_json::from_str(r#"{ "mode": "lenient" }"#).unwrap();
        let schema = default_doc_mapper.schema();
        assert_eq!(schema.num_fields(), 0);
        assert!(default_doc_mapper.default_search_field_names.is_empty());
    }

    #[test]
    fn test_dymamic_mode_schema() {
        let default_doc_mapper: DefaultDocMapper =
            serde_json::from_str(r#"{ "mode": "dynamic" }"#).unwrap();
        let schema = default_doc_mapper.schema();
        assert_eq!(schema.num_fields(), 1);
        let dynamic_field = schema.get_field(DYNAMIC_FIELD_NAME).unwrap();
        let dynamic_field_entry = schema.get_field_entry(dynamic_field);
        assert_eq!(dynamic_field_entry.field_type().value_type(), Type::Json);
        // the dynamic field will be added implicitly at search time.
        assert!(default_doc_mapper.default_search_field_names.is_empty());
    }

    #[test]
    fn test_dymamic_mode_schema_not_indexed() {
        let default_doc_mapper: DefaultDocMapper = serde_json::from_str(
            r#"{
            "mode": "dynamic",
            "dynamic_mapping": {
                "indexed": false,
                "stored": true
            }
        }"#,
        )
        .unwrap();
        let schema = default_doc_mapper.schema();
        assert_eq!(schema.num_fields(), 1);
        let dynamic_field = schema.get_field(DYNAMIC_FIELD_NAME).unwrap();
        let dynamic_field_entry = schema.get_field_entry(dynamic_field);
        if let FieldType::JsonObject(json_opt) = dynamic_field_entry.field_type() {
            assert_eq!(json_opt.is_indexed(), false);
        } else {
            panic!("Expected a json object");
        }
        default_doc_mapper.default_search_field_names.is_empty();
    }

    #[test]
    fn test_strict_mode_simple() {
        let default_doc_mapper: DefaultDocMapper =
            serde_json::from_str(r#"{ "mode": "strict" }"#).unwrap();
        let parsing_err = default_doc_mapper
            .doc_from_json_str(r#"{ "a": { "b": 5, "c": 6 } }"#)
            .err()
            .unwrap();
        assert!(
            matches!(parsing_err, DocParsingError::NoSuchFieldInSchema(field_name) if field_name == "a")
        );
    }

    #[test]
    fn test_strict_mode_inner() {
        let default_doc_mapper: DefaultDocMapper = serde_json::from_str(
            r#"{
            "field_mappings": [
                {
                    "name": "some_obj",
                    "type": "object",
                    "field_mappings": [
                        {
                            "name": "child_a",
                            "type": "text"
                        }
                    ]
                }
            ],
            "mode": "strict"
        }"#,
        )
        .unwrap();
        assert!(default_doc_mapper
            .doc_from_json_str(r#"{ "some_obj": { "child_a": "hello" } }"#)
            .is_ok());
        let parsing_err = default_doc_mapper
            .doc_from_json_str(r#"{ "some_obj": { "child_a": "hello", "child_b": 6 } }"#)
            .err()
            .unwrap();
        assert!(
            matches!(parsing_err, DocParsingError::NoSuchFieldInSchema(field_name) if field_name == "some_obj.child_b")
        );
    }

    #[test]
    fn test_lenient_mode_simple() {
        let default_doc_mapper: DefaultDocMapper =
            serde_json::from_str(r#"{ "mode": "lenient" }"#).unwrap();
        let (_, doc) = default_doc_mapper
            .doc_from_json_str(r#"{ "a": { "b": 5, "c": 6 } }"#)
            .unwrap();
        assert_eq!(doc.len(), 0);
    }

    #[test]
    fn test_dymamic_mode_simple() {
        let default_doc_mapper: DefaultDocMapper =
            serde_json::from_str(r#"{ "mode": "dynamic" }"#).unwrap();
        let schema = default_doc_mapper.schema();
        let dynamic_field = schema.get_field(DYNAMIC_FIELD_NAME).unwrap();
        let (_, doc) = default_doc_mapper
            .doc_from_json_str(r#"{ "a": { "b": 5, "c": 6 } }"#)
            .unwrap();
        let vals: Vec<&TantivyValue> = doc.get_all(dynamic_field).collect();
        assert_eq!(vals.len(), 1);
        if let TantivyValue::JsonObject(json_val) = &vals[0] {
            assert_eq!(
                serde_json::to_value(json_val).unwrap(),
                json!({
                    "a": {
                        "b": 5,
                        "c": 6
                    }
                })
            );
        } else {
            panic!("Expected json");
        }
    }

    #[test]
    fn test_dymamic_mode_inner() {
        let default_doc_mapper: DefaultDocMapper = serde_json::from_str(
            r#"{
            "field_mappings": [
                {
                    "name": "some_obj",
                    "type": "object",
                    "field_mappings": [
                        {
                            "name": "child_a",
                            "type": "text"
                        }
                    ]
                }
            ],
            "mode": "dynamic"
        }"#,
        )
        .unwrap();
        let (_, doc) = default_doc_mapper
            .doc_from_json_str(
                r#"{ "some_obj": { "child_a": "", "child_b": {"c": 3} }, "some_obj2": 4 }"#,
            )
            .unwrap();
        let dynamic_field = default_doc_mapper
            .schema()
            .get_field(DYNAMIC_FIELD_NAME)
            .unwrap();
        let vals: Vec<&TantivyValue> = doc.get_all(dynamic_field).collect();
        assert_eq!(vals.len(), 1);
        if let TantivyValue::JsonObject(json_val) = &vals[0] {
            assert_eq!(
                serde_json::to_value(json_val).unwrap(),
                serde_json::json!({
                    "some_obj": {
                        "child_b": {
                            "c": 3
                        }
                    },
                    "some_obj2": 4
                })
            );
        } else {
            panic!("Expected json");
        }
    }

    #[test]
    fn test_json_object_in_mapping() {
        let default_doc_mapper: DefaultDocMapper = serde_json::from_str(
            r#"{
            "field_mappings": [
                {
                    "name": "some_obj",
                    "type": "object",
                    "field_mappings": [
                        {
                            "name": "json_obj",
                            "type": "json"
                        }
                    ]
                }
            ],
            "mode": "strict"
        }"#,
        )
        .unwrap();
        let (_, doc) = default_doc_mapper
            .doc_from_json_str(r#"{ "some_obj": { "json_obj": {"hello": 2} } }"#)
            .unwrap();
        let json_field = default_doc_mapper
            .schema()
            .get_field("some_obj.json_obj")
            .unwrap();
        let vals: Vec<&TantivyValue> = doc.get_all(json_field).collect();
        assert_eq!(vals.len(), 1);
        if let TantivyValue::JsonObject(json_val) = &vals[0] {
            assert_eq!(
                serde_json::to_value(json_val).unwrap(),
                serde_json::json!({
                    "hello": 2
                })
            );
        } else {
            panic!("Expected json");
        }
    }

    fn default_doc_mapper_query_aux(
        doc_mapper: &dyn DocMapper,
        query: &str,
    ) -> Result<String, String> {
        let search_request = SearchRequest {
            query: query.to_string(),
            ..Default::default()
        };
        let (query, _) = doc_mapper
            .query(doc_mapper.schema(), &search_request)
            .map_err(|err| err.to_string())?;
        Ok(format!("{query:?}"))
    }

    #[test]
    fn test_doc_mapper_sub_field_query_on_non_json_field_should_error() {
        let doc_mapper: DefaultDocMapper = serde_json::from_str(
            r#"{
            "field_mappings": [{"name": "body", "type": "text"}],
            "mode": "dynamic"
        }"#,
        )
        .unwrap();
        assert_eq!(
            default_doc_mapper_query_aux(&doc_mapper, "body.wrong_field:hello").unwrap_err(),
            "Field does not exist: 'body.wrong_field'"
        );
    }

    #[test]
    fn test_doc_mapper_accept_sub_field_query_on_json_field() {
        let doc_mapper: DefaultDocMapper = serde_json::from_str(
            r#"{
            "field_mappings": [{"name": "body", "type": "json"}],
            "mode": "dynamic"
        }"#,
        )
        .unwrap();
        assert_eq!(
            default_doc_mapper_query_aux(&doc_mapper, "body.dynamic_field:hello"),
            Ok(
                r#"TermQuery(Term(type=Json, field=0, path=dynamic_field, vtype=Str, "hello"))"#
                    .to_string()
            )
        );
    }

    #[test]
    fn test_doc_mapper_object_dot_collision_with_object_field() {
        let doc_mapper: DefaultDocMapper = serde_json::from_str(
            r#"{
            "field_mappings": [
                {
                    "name": "identity",
                    "type": "object",
                    "field_mappings": [{"type": "text", "name": "username"}]
                },
                {"type": "text", "name": "identity.username"}
            ]
        }"#,
        )
        .unwrap();
        assert_eq!(
            default_doc_mapper_query_aux(&doc_mapper, "identity.username:toto").unwrap(),
            r#"TermQuery(Term(type=Str, field=0, "toto"))"#
        );
        assert_eq!(
            default_doc_mapper_query_aux(&doc_mapper, r#"identity\.username:toto"#).unwrap(),
            r#"TermQuery(Term(type=Str, field=1, "toto"))"#
        );
    }

    #[test]
    fn test_doc_mapper_object_dot_collision_with_json_field() {
        let doc_mapper: DefaultDocMapper = serde_json::from_str(
            r#"{
            "field_mappings": [
                {"name": "identity", "type": "json"},
                {"type": "text", "name": "identity.username"}
            ]
        }"#,
        )
        .unwrap();
        assert_eq!(
            default_doc_mapper_query_aux(&doc_mapper, "identity.username:toto").unwrap(),
            r#"TermQuery(Term(type=Json, field=0, path=username, vtype=Str, "toto"))"#
        );
        assert_eq!(
            default_doc_mapper_query_aux(&doc_mapper, r#"identity\.username:toto"#).unwrap(),
            r#"TermQuery(Term(type=Str, field=1, "toto"))"#
        );
    }
}
